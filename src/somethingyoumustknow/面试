1 hashmap实现   hashcode取余相等太多导致链太长怎么解决   链太长用树状结构为什么树状结构会好点
优化上述的办法就是减少“碰撞”，如何减少“碰撞”？
答案：
1>String, Interger这样的wrapper类作为HashMap的键；而且String最为常用，因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变
使用自定义的对象作为键时遵守重写equals()和hashCode()方法的规则，保证不同的对象不要出现相同的hashCode；
2>在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。

2 map怎么排序  用什么现成的可以做到排序    currnhashmap怎么实现
1>继承了sortMap的treeMap等都可以做到排序 插入有序映射的所有键都必须实现 Comparable 接口
2>我理解的currentHashMap  引入了分段锁概念  定义其实是一个继承了ReentrantLock的数组 默认大小是16 这个可以改  小的话锁竞争激烈  大的话 cpu cache命中率低 性能低
然后内部拥有一个Entry数组 命名为hashEntry  value跟next都是由volatile修饰保证可见性 这样的话就像是把一个hashMap切成几个hashTable
其中get与containsKey 是不加锁操作的 是弱一致性  如果要求强一致性，那么必须使用Collections.synchronizedMap()方法。
put跟remove是需要申请锁的  申请锁之前还会遍历链表的并且保证了遍历不受并发影响  目的是为了提升cpu cache命中率 提升性能
size、containsValue 比较特殊方法类似  size是循环所有的segment计算所有size和  然后如果有count两次一样 则返回 一般来说，应该避免在多线程环境下使用size和containsValue方法。
最后，与HashMap不同的是，ConcurrentHashMap并不允许key或者value为null，按照Doug Lea的说法，这么设计的原因是在ConcurrentHashMap中，一旦value出现null，则代表HashEntry的key/value没有映射完成就被其他线程所见，需要特殊处理
jdk8有改变 不采用segment而采用node，锁住node来实现减小锁粒度。 设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。
使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。 sizeCtl的不同值来代表不同含义，起到了控制的作用

3 线程有几个状态   线程的阻塞态怎么产生的    不用锁怎么让线程防止并发
1>new新建 runnable 就绪(拿到所有资源等待cpu分配) running 运行
blocked 阻塞
(1)等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，
(2)同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。
(3)其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
dead(终止)
2>使用ThreadLocal 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本
  原理其实内置一个map ,Map中元素的键为线程对象，而值对应线程的变量副本，注意在线程池用到时，因为线程池里的线程是重复利用的，所以当线程走完时要手动更新掉。

4 解释一下IO  NIO  BIO 解释同步异步  阻塞非阻塞



5 dubbo怎么实现调用的    dubbo的调用负载均衡怎么实现
1> 一个dubbo那就分成调用者（provider）跟消费者（consumer） 首先服务提供的系统启动会在注册中心注册自己的服务，这些服务就是配置文件你配的相关服务，注册到zk上的信息其实就是你提供者的IP信息以及服务方法等相关信息
   然后消费者系统启动时会向注册中心订阅所需服务，这个订阅就是告诉注册中心我要消费的方法有变动时把信息推送过来，如提供者有服务器挂掉了等等
   然后一个消费者消费一个服务时经过代理层获取一个代理，这个代理是经过cluster层做一些负载均衡，路由配置等处理，这一层会拿到这层中心要调用的服务相关信息，本地缓存也有，所以注册中心挂掉了也是能掉服务的。
   然后经过上面cluster层会返回一个处理好的invoker，然后调用时会根据不要同协议例如dubbo、rmi、hessian、等等调用不同的protocol，里面会调用refer方法，返回一个可供通信的invoker，
   然后另一方面服务提供者方，会把提供出去的dubbo服务先通过proxy层proxyFactory里的getinvoker方法获取一个abstractProxyInvoker实例。
   然后上面消费者调用invoker.invoke()方法时会根据协议执行相同URL远端export（）传入的invoker对象的invoker方法，对于提供方收到一个请求就找到对应的exporter实例，找到对应的abstractProxyInvoker实例，从而调用真正的方法。
2>负载均衡如上面在cluster层做的，也就是consumer调用服务时候做的，默认的策略是随机的，也就是根据你设置的权重来分配请求或者说是分配所需要的invoker，还有轮询策略等等

6 为什么用redis不用memacache   redis好在哪里    redis你都会存些什么  假如redis的key失效，大量高并发请求到数据库，压力变大怎么办？
1>redis支持的数据类型多 String List Set Hash sortSet  支持持久化  支持事务  存取速度比memacache快
2>存取速度快  直接存到内存  有丰富的特性 设置过期时间 数据过期策略保存热点数据的是volatile-lru()
3>redis的持久化依靠 RDB内存快照（在指定时间点内fork出一条进程生成数据集的时间点快照，适合灾难恢复，因为fork进程设置频率不能太高）以及AOF（日志文件：只追加写的日志文件，类似于mysql的binlog，记录有效的写操作记录，日志到达一定是会fork一条进程重写文件，一般这个大小是上次的两倍），两个都启用的时候，服务重启优先AOF
4>RDB利于数据备份，而AOF更完整，同步有设置的策略默认每秒一次，RDB问题更少，AOF日志文件也容易读懂，RDB相对速度更快一点，各有优缺点，愿意忽略几分钟的数据用RDB。
5>RDB基本是新写一个文件替换旧文件，AOF重写则是子进程新建文件copy旧文件，父进程一边把新加的操作保存到内存缓存集一遍在原文件追加，子进程操作完，父进程把缓存追加到新文件，删除旧文件。
6>面对这种情况，可以在常规的缓存更新时加锁，这样只有一个能够请求去DB去查询或者更新，其他返回等待或者反面，做好读完数据库就存redis，如果redis大面积失效，数据库层真的顶不住压力，分业务，做好预案，redis做好slave服务，
做好非核心服务降级的准备，指定网址不能访问，数据库只能查，api调用延迟代用丢到消息中间件等。

7 讲一个你自己实现的能表现你能力的例子

8 mysql怎么优化     怎么防止脏读的    mysql怎么实现这些的
1>联合索引尽量将频率比较高的列放在前面     索引尽可能少      mysql自带的函数里面如果有索引是没有用的    索引只会在数据抓取时起作用即where条件时
2>避免全表查询 在where或者order by的列上加索引   少使用！= 或者< > 操作符 ，少对列作null值判断（可设置为0），少使用or可以用（union），少用in或者not in （能用between就用between），
避免在where中 在等号左边进行表达式操作，函数操作，这个会不使用索引的
少用like %abc%这种条件，若为联合索引就要保证联合索引第一个字段作为查询条件尽量保持顺序一致，exit比in好点，
假如列里面大量数居重复，还不如不建索引，因为用不上，能用数字型的就用数字型的，减少存储空间，提升查询链接效率，毕竟字符型的要逐个比对字符，查询尽量查询具体字段不要用*
尽量避免大事务操作，提高并发

9 为什么要用dubbo+redis这个架构    你觉得怎么优化

10 我简历上写我研究过spring启动   他就问了一下
1>就xml配置的bean注入吧，源码里面大致的过程是先调用classResourcePath读取对应的Xml，然后new一个BeanFactory，xml注入的是新建一个defaultListableBeanFactory，然后
new一个XmlDefinitionReader，入参是刚刚的BeanFactory，然后调用reader.loadBeanDefinition（classResourcePath），完成注入
2>spring声明式事务主要是利用AOP的思想通过代理类插入事务，提交或者回滚事务。而编程式事务主要是基于PlatformTransactionManager来管理事务，前面只能到方法级别，后面可以到代码块级别，
实现机制主要是在beginTranscation阶段，spring把与数据库链接的connection对象的autoCommit设置为false，然后在endTranscation阶段做提交回滚操作
其中与数据库的Connection通过ThreadLocal对不同线程提供不同副本，线程之间是不影响的
3>对于声明式事务要小心方法要public的，然后新建一个方法自己掉自己时是不生效的，主要是因为声明式事务基于aop的，然后aop有两个实现方式，一个是java动态代理，一个是cjlib，后者比前者强，spring抽象了这些，去掉了cjlib能够获取增强子类，
导致子类只能调方法而不识别标签效果，解决办法是让当前调用子方法时用代理类调用，或者用application.getbean来get当前bean然后用它调用。
4>默认对runTimeException回滚对其他不会滚，可以改rollbackFor=Exception.class对所有回滚，也可以rollbackFor=runTimeException.class都不回滚

11  如果数据库宕机了怎么办
做备库，切到备库上

12  怎么做到容灾的

13 jvm怎么调优
1> 可以用JDK自带的visualVM，也可以用Jconsole,观察内存释放情况、集合类检查、对象树,年轻代、年老代、持久代分配。
2> 堆满了的话 查查代码集合对象引用，持久代满了的话，加大持久代空间，堆栈溢出的话则看看代码是否有递归循环调用，线程堆栈满了的话则可以增加线程栈大小，主要是检查代码是否有泄漏，
系统内存占满，减少线程数量，减小单个线程大小

14 如何优化一个很耗事的服务  这个服务里面既有你调用别人的 也有别人调用你的

15 线上出现大面积错误时怎么办
切流量，如果服务器压力大的话做好预案  服务降级。

16 aop怎么理解

17 for update什么时候可以用？
就是那些需要业务层面数据独占时，可以考虑使用for update。场景上，比如火车票订票，在屏幕上显示邮票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。所以，在这个确认过程中，可以使用for update。这是统一的解决方案方案问题，需要前期有所准备。

18java锁实现机制？
jvm层有contentionList emptyList  oneDeck  Owner  !Owner    需要竞争锁的线程会并发进入contentionList（虚拟队列，遵循后进先出，队列头遵循CAS改变，因为对尾只能是Owner操作，出列无竞争，则不会出现CAS的ABA问题，）  当获得锁的Owner释放锁的时候  会从contentionList把线程移至emptyList
之所以要把队列移至emptyList是因为要降低对队尾的竞争情况，然后指定某个线程为Ready线程即进入到OneDeck，OneDeck来竞争锁（增加吞吐量），竞争到了即为Owner，若Owner调用wait则进入waitSet队列等待notify/notifyall唤醒进入emptyList

19 线程池相关问题
1>要避免死锁 例如工作线程在等待线程A执行结果，但是线程A仍然在队列中等待其他线程释放资源，就造成死锁，不要把这种线程丢到线程池内
2>系统资源不足 创建太多线程 合理设置线程池大小
3>尽量用java自带的线程池
4>尽量不要造成线程泄露，某些线程出现错误但是错误未被捕捉，这样线程池就废弃掉了这条线程，太多了线程池将不可用，长时间的有可能造成阻塞的线程设置超时时间
5>避免任务过载
6>多个线程协调工作的话如果要求等其他线程完成之后本线程才开始则用countDownLatch，若要求多个线程同时一起开始运行则用CyclicBarrier。

